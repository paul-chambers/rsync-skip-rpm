/*
	Scan the rpm database for this machine. and emit rsync 
	filter files that exclude the files provided by rpm
	packages that have not been modified since installation.
*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h>

#include <rpmlib.h>
#include <rpmlog.h>
#include <rpmcli.h>
#include <rpmdb.h>

#include <popt.h>

 /* globals */
static struct
{
	const char *	myname;
	int				outputpackagename;
    unsigned long	excluded, totalfiles;
    size_t			saved, totalsize;
    time_t			started;
    char			*packagename;
    FILE			*outputfile;
} g;

/* Set up a table of options. */

static struct poptOption optionsTable[] = {
	{ NULL, 'p', POPT_ARG_NONE, &g.outputpackagename, 0,
	  "Include package names in the generated .rpm-filter files", NULL },
	{ NULL, '\0', POPT_ARG_INCLUDE_TABLE, rpmcliAllPoptTable, 0,
	  "Common options for all rpm modes and executables:", NULL },
	POPT_AUTOALIAS
	POPT_AUTOHELP
	POPT_TABLEEND
};

int sizeToUnits(char *dest, int len, size_t size)
{
	int magnitude;
	size_t s;
	const char *units;
	double f;

	s = size;
	magnitude = 0;
	do {
		s = s >> 10;	// shift by 10 bits, i.e. divide by 1024
		++magnitude;
	} while (s != 0);
	--magnitude;

	switch (magnitude)
	{
	default: magnitude = 0;
		/* and fall through */
	case 0:	units = "bytes";	break;
	case 1:	units = "KB";	break;
	case 2:	units = "MB";	break;
	case 3:	units = "GB";	break;
	case 4:	units = "TB";	break;
	}

	f = (size * 1.0) / (1 << (10 * magnitude));

	// repurpose 'magnitude' to indicate number of decimal places to display
	// e.g. 0 = "123 GB", 1 = "45.6 KB", 2 = "7.89 TB"
	if (magnitude > 0)
	{
		if (f < 10.0)
			magnitude = 2;
		else if (f < 100.0)
			magnitude = 1;
		else
			magnitude = 0;
	}

	return snprintf(dest, len, "%.*f %s", magnitude, f, units);
}


char *strdupcat(const char *base, const char *suffix)
{
	char 	*dest, *p;
	size_t	destLen;
	
	destLen = strlen(base) + strlen(suffix) + 1; /* don't forget the null */
	dest = malloc(destLen);
	if (dest != NULL)
	{
		p = memccpy(dest, base, '\0', destLen);
		if (p != NULL)
		{
			--p; /* overwrite the trailing null that was copied from base */
			p = memccpy(p, suffix, '\0', destLen - (p - dest));
		}
		if (p == NULL)
		{
			free(dest);
			dest = NULL;
		}
	}

	return dest;
}


/*
	returns a file descriptor, or stdout on failure
*/
FILE *getOutputFile(const char *directory)
{
    FILE *file;
    int len;
    char *path;
    int append;
    struct stat	fsStat;
    struct tm	*tmp;
    char		timestr[80];

	file = g.outputfile;
	if (file == NULL)
	{
		if (directory != NULL && strlen(directory) > 0)
		{
			path = strdupcat( directory, ".rpm-filter");
			if (path != NULL)
			{
				append = 0;
				if (lstat(path, &fsStat) != 0)
				{
					switch (errno)
					{
					case ENOENT:
						/* normal case, we need to create the file */
						/* fprintf(stderr,">> new: %s\n", path); */
						break;

					default:
						fprintf(stderr, "### Unable to stat %s (%s [%d])\n", path, strerror(errno), errno);
						break;
					}
				}
				else if (S_ISREG(fsStat.st_mode))
				{
					append = (fsStat.st_ctime >= g.started);
					/* fprintf(stderr,">> %s: %s\n", append ? "cur" : "old", path); */
				}

				file = fopen(path, append ? "a+" : "w+");
				if (file == NULL)
				{
					fprintf(stderr,"### Unable to open %s (%s [%d])\n", path, strerror(errno), errno);
					file = stdout;
				}

				g.outputfile = file;
				if (!append)
				{
					tmp = localtime(&g.started);
					if (tmp != NULL)
					{
						strftime(timestr, sizeof(timestr), "%x %X %Z", tmp);
						fprintf(file, "# generated by %s at %s\n", g.myname, timestr);
					}
				}

				if (g.outputpackagename)
				{
					fprintf(file, "# %s\n", g.packagename);
				}

				free(path);
			}
		}
	}

	return file;
}

void cleanupOutput(const char *directory)
{
    FILE *file;
    char *path;
    struct stat	fsStat;

	if (directory != NULL && strlen(directory) > 0)
	{
		path = strdupcat( directory, ".rpm-filter");
		if (path != NULL)
		{
			if (lstat(path, &fsStat) != 0)
			{
				switch (errno)
				{
				case ENOENT:
					/* nothing to do */
					break;

				default:
					fprintf(stderr, "### Unable to stat %s (%s [%d])\n", path, strerror(errno), errno);
					break;
				}
			}
			else if (S_ISREG(fsStat.st_mode))
			{
				if (fsStat.st_ctime < g.started)
				{
					/* fprintf(stderr,"Delete %s\n", path ); */
					if (unlink(path) != 0)
						fprintf(stderr, "### Unable to unlink %s (%s [%d])\n", path, strerror(errno), errno);
				}
			}

			free(path);
		}
	}
}

void closeOutput(void)
{
	if (g.outputfile != NULL)
	{
		if (g.outputfile != stdout && g.outputfile != stderr)
			fclose(g.outputfile);

		g.outputfile = NULL;
	}
}


int processFile( const char *directory, const char *basename, unsigned short fileMode, unsigned long fileMtime)
{
	int		result;
    struct stat		fsStat;
    char	*path;
    int		excludeFile;

	result = -1;
	path = strdupcat( directory, basename );
	if (path != NULL)
	{
		if (lstat(path, &fsStat) != 0)
		{
			switch (errno)
			{
			case ENOENT:
				/* can't back up something that doesn't exist, so silently ignore it */
				result = 0;
				break;

			default:
				fprintf(stderr, "### Unable to stat %s (%s [%d])\n", path, strerror(errno), errno);
				result = errno;
				break;
			}
		}
		else {
			if (S_ISREG(fsStat.st_mode))
			{
				++g.totalfiles;
				g.totalsize += fsStat.st_size;
				
				excludeFile = ( (fsStat.st_mode == fileMode)
							&& (fsStat.st_mtime == fileMtime) );
				
				if (excludeFile)
				{
					fprintf( getOutputFile(directory), "- %s\n", basename );
					++g.excluded;
					g.saved += fsStat.st_size;
				}
			}
			result = 0;
		}
		free(path);
	}
    return result;
}

int processPackage(Header header)
{
    unsigned long type, size;
    unsigned long dircount, i, filecount, j;
    unsigned long *filemtimes, *dirindexes;
    unsigned short *filemodes;
    char **dirnames, **basenames;
    int err;
    FILE *file;

    headerGetEntry(header, RPMTAG_NAME, &type, &g.packagename, &size);

    err = headerGetEntry(header, RPMTAG_BASENAMES, &type, &basenames, &filecount);	/* s[] */
    if (filecount == 0)
	return 0;

    if (err != 1 || type != RPM_STRING_ARRAY_TYPE || basenames == NULL)
    {
		fprintf(stderr, "### RPMTAG_BASENAMES failed\n");
		return -1;
    }
    
    err = headerGetEntry(header, RPMTAG_DIRNAMES, &type, &dirnames, &dircount);	/* s[] */
    if (err != 1 || type != RPM_STRING_ARRAY_TYPE || dirnames == NULL)
    {
		fprintf(stderr, "### RPMTAG_DIRNAMES failed\n");
		return -2;
    }
    
    err = headerGetEntry(header, RPMTAG_FILEMODES, &type, &filemodes, &size);		/* h[] */
    if (err != 1 || type != RPM_INT16_TYPE || size != filecount || filemodes == NULL)
    {
		fprintf(stderr, "### RPMTAG_FILEMODES failed\n");
		return -3;
    }

    err = headerGetEntry(header, RPMTAG_FILEMTIMES, &type, &filemtimes, &size);	/* i[] */
    if (err != 1 || type != RPM_INT32_TYPE || size != filecount || filemtimes == NULL)
    {
		fprintf(stderr, "### RPMTAG_FILEMTIMES failed\n");
		return -4;
    }
    
    err = headerGetEntry(header, RPMTAG_DIRINDEXES, &type, &dirindexes, &size);	/* i[] */
    if (err != 1 || type != RPM_INT32_TYPE || size != filecount || dirindexes == NULL)
    {
		fprintf(stderr, "### RPMTAG_DIRINDEXES failed\n");
		return -5;
    }
    
    for (i = 0; i < dircount; ++i)
    {
		cleanupOutput(dirnames[i]);
		for (j = 0; j < filecount; ++j)
		{
			if (dirindexes[j] == i)
			{
				if (processFile( dirnames[i], basenames[j], filemodes[j], filemtimes[j]) != 0)
				{
					fprintf(stderr, "### failed to process file %s%s\n", dirnames[i], basenames[j] );
				}
			}
		}
		closeOutput();
    }
    return 0;
}


int main(int argc, char * argv[])
{
    int status;
    poptContext context;
    rpmts ts;
    rpmdbMatchIterator iter;
    Header header;
	char totalSizeAsStr[48], savedSizeAsStr[48];
	
	size_t i;

    g.started = time(NULL);
    g.saved = 0;
    g.excluded = 0;
    g.totalfiles = 0;
    g.totalsize = 0;
    g.packagename = NULL;
    g.outputfile = NULL;
    
	g.myname = strrchr(argv[0], '/') + 1;
	if (g.myname == (NULL+1))
		g.myname = argv[0];

	status = rpmReadConfigFiles( (const char*) NULL, (const char*) NULL);
    context = rpmcliInit( argc, argv, optionsTable);

    if (status != 0) {
		fprintf(stderr, "### Error reading RC files.\n");
		exit(-1);
    }

	rpmSetVerbosity(RPMLOG_INFO);
    /* rpmShowRC( stdout ); */

    ts = rpmtsCreate();

    iter = rpmtsInitIterator(ts, RPMDBI_PACKAGES, NULL, 0);

    while ( (header = rpmdbNextIterator(iter) ) != NULL)
    {
		if (processPackage(header) != 0)
			break;
    }

    rpmtsFree(ts);

/*
	for (i = 1; i > 0; i <<= 1)
	{
		sizeToUnits(totalSizeAsStr, sizeof(totalSizeAsStr), i);
		fprintf(stderr, "test: %lu - %s\n", i, totalSizeAsStr);
	}
*/

	sizeToUnits(totalSizeAsStr, sizeof(totalSizeAsStr), g.totalsize);
	sizeToUnits(savedSizeAsStr, sizeof(savedSizeAsStr), g.saved);

	fprintf(stderr, "Total files: %u\n", g.totalfiles);
    fprintf(stderr, "Total size:  %s\n", totalSizeAsStr);

	fprintf(stderr, "Files excluded: %u (%.1f%%)\n",
			g.excluded,
			g.excluded * 100.0 / g.totalfiles);

    fprintf(stderr, "Space saved: %s (%.1f%%)\n",
			savedSizeAsStr,
			g.saved * 100.0 / g.totalsize);

    rpmcliFini(context);

    exit(0);
}

